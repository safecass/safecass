/*

  Safety Framework for Component-based Robotics

  Created on: January 7, 2012

  Copyright (C) 2012 Min Yang Jung, Peter Kazanzides

  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)

*/

#ifndef _FilterBase_h
#define _FilterBase_h

#include <iostream>
#include <sstream>

#include "signal.h"
#include "eventLocationBase.h"
#include "json.h"

namespace SF {

class HistoryBufferBase;
class EventPublisherBase;

class SFLIB_EXPORT FilterBase
{
public:
    /*! Typedef for filtering type.
        ACTIVE:  filter is processed by the target component and thus the execution time of 
                 the target component is consumed.
                 - Pros: Fastest and guaranteed detection of an event
                 - Cons: Run-time overhead to execute FDD pipelines and generate and propagate events
        PASSIVE: filter is processed by the monitoring component which does not require the 
                 execution time of the target component.
                 - Pros: No run-time performance impact on the target component
                 - Cons: Delay in detecting an event (currently, monitoring component is periodic task) */
    typedef enum { ACTIVE, PASSIVE } FilteringType;

    /*! Typedef for filter categories */
    typedef enum {
        INVALID,        // invalid filter is not processed
        FEATURE,        // raw measurement processed 
        FEATURE_VECTOR, // collection of features
        SYMPTOM,        // feature vectors processed
        SYMPTOM_VECTOR, // collection of symptoms
        FAULT_DETECTOR  // fault detector
    } FilterCategory;

    /*! Input signal element.  A filter may need more than one signal to run 
        its filtering algorithm and this class represents a signal. */
    typedef std::vector<SignalElement*> SignalElementsType;
    // not used now
    //typedef std::vector<std::string> SignalNamesType;

    /*! Typedef for filter id */
    typedef int FilterIDType;

private:
    /*! ID of this filter which allows multiple filters of the same type to be 
        used in the same state table. */
    static FilterIDType FilterUID;

protected:
    /*! Typedef of base class for derived classes */
    typedef FilterBase BaseType;

    /*! UID of this filter */
    const FilterIDType UID;
    /*! Name of this filter */
    const std::string Name;
    /*! Category of this filter */
    const FilterCategory Category;
    /*! Name of target component */
    const std::string NameOfTargetComponent;
    /*! Filtering type (active or passive) */
    const FilteringType Type;
    /*! Is this filter the last one of a FDD pipeline? */
    bool LastFilterOfPipeline;
    /*! Print out internal debug log of this filter if enabled */
    bool PrintDebugLog;

    /*! State of this filter (enabled or disabled) */
    bool Enabled;

    /*! Input signals that this filter uses */
    SignalElementsType InputSignals;
    /*! Output signals that this filter generates */
    SignalElementsType OutputSignals;

    /*! Helper function to register input signal to this filter (used by derived filters) */
    bool AddInputSignal(const std::string &       signalName, 
                        SignalElement::SignalType signalType);
    /*! Helper function to register output signal generated by filter (used by derived filters) */
    bool AddOutputSignal(const std::string &       signalName, 
                        SignalElement::SignalType  signalType);

    /*! Generate name of output signal.
        Prefix: Name of input signal or input-specific word
        Root1 : Filter name
        Root2 : Filter UID
        Suffix: Signal id */
    std::string GenerateOutputSignalName(const std::string & prefix,
                                         const std::string & root1,
                                         const FilterIDType  root2,
                                         size_t              suffix) const;

    /*! Generate fault diagnosis and identification (FDI) string in JSON format.
        Filter-specific.  Returned string should include the following information:
        
            - Fault type
            - Fault location (spatial localization)
            - Fault time (temporal localization)
            - Fault severity
    */
    virtual const std::string GenerateFDIJSON(double severity, double timestamp) const = 0;

    //-------------------------------------------------- 
    //  Middleware-specific Instances
    //-------------------------------------------------- 
    /*! Instance of history buffer that this filter runs on.  Dynamically allocated as 
        middleware-specific plug-in (i.e., history buffer accessor adapter) */
    //HistoryBufferBase * HistoryBuffer; // am I using this??? Probably not...

    /*! Instance of object that enables event propagation to the Safety Framework.
        Dynamically allocated as middleware-specific plug-in (event propagation 
        accessor adapter) */
    EventPublisherBase * EventPublisher;

    /*! Instance of event or fault location.  If the EventLocationBase class does not have 
        enough fields to identify an event location in a system, a middleware-specific event
        location class can be defined, inheriting the base class. */
    EventLocationBase * EventLocation;

    //-------------------------------------------------- 
    //  Constructors and Destructor
    //-------------------------------------------------- 
    // Filter has to be created with explicit type and name.
protected:
    FilterBase(void);
public:
    FilterBase(const std::string & filterName,
               FilterCategory      filterCategory,
               const std::string & targetComponentName,
               FilteringType       monitoringType);
    virtual ~FilterBase();

#if 0 // MJ: future improvements
    /*! Add input signal to this filter.  A placeholder of appropriate type 
        is created internally to fetch new values from the state table. */
    bool AddInput(const std::string & componentName, const std::string & signalName);
    // TODO: push_back (name), prepare placeholder to fetch new input values from state table

    // TODO: add an option to expose an output to the standardized provided interface.
    // This can be useful if the monitoring component wants to fetch output values when a filter 
    // is attached to the source component.
    bool AddOutput(const std::string & signalName); 
#endif
    /*! Run filtering algorithm which should be defined and implemented by derived filters */
    virtual void DoFiltering(void) = 0;

    /*! Declare this filter as the last filter of a FDD pipeline.  This internally creates
        a monitor to publish filtering results, i.e., events or faults, to the Safety Framework, 
        and attaches the monitor to this filter. */
    inline void DeclareLastFilterOfPipeline(void) { LastFilterOfPipeline = true; }

    //-------------------------------------------------- 
    //  Getters and Setters
    //-------------------------------------------------- 
    inline FilterIDType        GetFilterUID(void) const { return UID; }
    inline const std::string & GetFilterName(void) const { return Name; }
    inline FilterCategory      GetFilterCategory(void) const { return Category; }
    inline const std::string & GetNameOfTargetComponent(void) const { return NameOfTargetComponent; }
    inline FilteringType       GetFilteringType(void) const { return Type; }
    inline bool IsLastFilterOfPipeline(void) const { return LastFilterOfPipeline; }

    inline bool IsEnabled(void) const { return Enabled; }
    inline void Enable(bool enable = true) { this->Enabled = enable; }

    inline size_t GetNumberOfInputs(void) const { return InputSignals.size(); }
    inline size_t GetNumberOfOutputs(void) const { return OutputSignals.size(); }

    std::string GetInputSignalName(size_t index) const;
    std::string GetOutputSignalName(size_t index) const;

    // not used now
    //SignalNamesType GetInputSignalNames(void) const;
    //SignalNamesType GetOutputSignalNames(void) const;

    SignalElement * GetInputSignalElement(size_t index) const;
    SignalElement * GetOutputSignalElement(size_t index) const;

    /*! Sets event publisher instance.  Should be called before activating filter (or signal) */
    void SetEventPublisherInstance(EventPublisherBase * publisher);
    /*! Sets event location instance.  Should be called before activating filter */
    void SetEventLocationInstance(EventLocationBase * location);

    /*! Enable or disable internal debug log */
    inline void EnableDebugLog(bool enable = true) { PrintDebugLog = enable; }

    /*! Returns human readable outputs (for debugging purpose) */
    virtual std::string ToString(void) const  {
        std::stringstream ss;
        ToStream(ss);
        return ss.str();
    };
    virtual void ToStream(std::ostream & outputStream) const;
};

inline std::ostream & operator << (std::ostream & outputStream, const FilterBase & filter)
{
    filter.ToStream(outputStream);
    return outputStream;
}

};

#endif // _FilterBase_h
